<!doctype html> 
<html lang="en"> 
<head> 
    <meta charset="UTF-8" />
    <title>new map design test</title>
    <script src="assets/easystar.js"></script>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.52.0/dist/phaser.js"></script>
   <style type="text/css">
        body {
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background: #111
        }
    </style>
</head>
<body>

<script type="text/javascript">

   var config = {
        type: Phaser.AUTO,
        width: 800,
        height: 600,
        physics: {
            default: 'arcade',
            arcade: {
                gravity: {y : 0},
                debug: false
            }
        },
        scene: {
            preload: preload,
            create: create,
            update: update
        },
         pixelArt: true,
        //  zoom: 1.5
    };
    var game = new Phaser.Game(config);
    var player;
    var tween=null;
    var scene;
    var mouse;
    function preload ()
    {
        //loads the sprites and assets to be used
        this.load.image('tile', 'assets/tile.png')
        this.load.image('tilehover', 'assets/tile_outline.png')
        this.load.tilemapTiledJSON("map", "assets/7x7.json")
        this.load.spritesheet('habbo', 'assets/habbospritesheet.png', { frameWidth: 110, frameHeight: 221 });
    }
    function create ()
    {   
        scene = this;
        //debugging tools
        this.label = this.add.text(0, 0, '(x, y)', { fontFamily: '"Monospace"'});
        this.pointer = this.input.activePointer;

        // Set mouse variable and send to handleclick function on mouse up event
        this.input.on('pointerup',handleClick);
        mouse = this.input.mousePointer;

        //Create tilemap
        map = this.make.tilemap({key: 'map'})
        const tileset = map.addTilesetImage('roomtile', 'tile')
        worldLayer = map.createStaticLayer("ground", tileset, game.config.width/2,game.config.height/2);

        //creates habbo sprite and sets scale to match tilemap
        player = this.physics.add.sprite(431,316, 'habbo')
        player.setOrigin(0.5,1)
        player.setScale(0.5)

        //Pathfinding
        this.finder = new EasyStar.js();
        var grid = [];
        for(var y = 0; y < map.height; y++){
        var col = [];
        for(var x = 0; x < map.width; x++){
            // In each cell we store the ID of the tile, which corresponds
            // to its index in the tileset of the map ("ID" field in Tiled)
            col.push(getTileID(x,y));
        }
        grid.push(col);
        }
        this.finder.setGrid(grid);
        var tilesets = map.tilesets[0];
        var properties = tilesets.tileProperties;
        var acceptableTiles = [];

        for(var i = tilesets.firstgid-1; i < tileset.total; i++){ // firstgid and total are fields from Tiled that indicate the range of IDs that the tiles can take in that tileset
        if(!properties.hasOwnProperty(i)) {
            // If there is no property indicated at all, it means it's a walkable tile
            acceptableTiles.push(i+1);
            continue;
        }
        if(!properties[i].collide) acceptableTiles.push(i+1);
        if(properties[i].cost) this.finder.setTileCost(i+1, properties[i].cost); // If there is a cost attached to the tile, let's register it
        }
        this.finder.setAcceptableTiles(acceptableTiles);

        //Set Animations for habbo walking
        this.anims.create({
            key: 'left',
            frames: this.anims.generateFrameNumbers('habbo', {start: 1, end: 3}),
            frameRate: 10,
            repeat: -1
        });

        this.anims.create({
            key: 'right',
            frames: this.anims.generateFrameNumbers('habbo', { start: 4, end: 6 }),
            frameRate: 10,
            repeat: -1
        })
        this.anims.create({
            key: 'turn',
            frames: [{key: 'habbo', frame: 0}],
            frameRate: 20
        })
    }
    function update ()
    {
        this.label.setText('(' + this.pointer.x + ', ' + this.pointer.y + ')');   
    }

    const handleClick = (clickedLocation) => {
        pathfind(clickedLocation)
    }

    const pathfind = (clickedLocation) => {
        //Finds which Tile (x,y) user clicked and returns world position for it
        let tile = map.getTileAtWorldXY(clickedLocation.x, clickedLocation.y)
        let newX = map.tileToWorldXY(tile.x, tile.y).x + 28
        let newY = map.tileToWorldXY(tile.x, tile.y).y + 20


        // //If user clicks begins walk animation depending on click direction again only on X axis as of now
        // if (tween){
        //     console.log('Already walking')
        //     console.log('Stopping walking')
        //     tween.stop()
        // }
        // tween = scene.tweens.add({
        // onStart: () => {
        //     console.log(`Starting walking to X:${newX}-Y:${newY}`)
        //     if(newX < player.x){
        //         //player.flipX = true; could use for other sprite directions i dont have
        //         player.anims.play('left', true)
        //     }
        //     else if(newX > player.x){
        //         player.anims.play('right', true)
        //     }
        // },
        // targets: player,
        // x: newX,
        // y: newY,
        // duration: duration,
        // onComplete: onCompleteHandler
        // });

        //pathfinding    
        var fromX = map.getTileAtWorldXY(player.x, player.y).x
        var fromY = map.getTileAtWorldXY(player.x, player.y).y
        var toX = tile.x
        var toY = tile.y
        console.log(`%c pathfinding beginning`,'background: #222; color: #bada55')
        console.log('going from ('+fromX+','+fromY+') to ('+toX+','+toY+')');
        scene.finder.findPath(fromX, fromY, toX, toY, function( path ) {
        if (path === null) {
            console.warn("Path was not found.");
        } else {
            moveCharacter(path);
        }
        });
        scene.finder.calculate();
    }
    const onCompleteHandler = () =>{
        //stops walking animation this should stop on last player direction in the future
        console.log(`Finished walking, arrived at X:${player.x}-Y:${player.y}`)
        player.anims.play({key: 'turn'})
        tween = null;
    }
    getTileID = function(x,y){
        var tile = map.getTileAt(x, y);
        return tile.index;
    };

    const moveCharacter = (path) => {
         //prevents variable distance between tiles (currently only works for x axis)
        let distance = player.x - mouse.x;
        let speed = 500;
        let duration = (Math.sqrt(distance*distance) / speed) * 1000;

        //pathfinder
        var tweens = [];
        for(var i = 0; i < path.length-1; i++){
        var ex = path[i+1].x;
        var ey = path[i+1].y;
        console.log(ex,ey)
        let newX = map.tileToWorldXY(ex, ey).x + 28
        let newY = map.tileToWorldXY(ex,ey).y + 20
        tweens.push({
        onStart: () => {
            console.log(`Starting walking to X:${newX}-Y:${newY}`)
            if(newX < player.x){
                //player.flipX = true; could use for other sprite directions i dont have
                player.anims.play('left', true)
            }
            else if(newX > player.x){
                player.anims.play('right', true)
            }
        },
        targets: player,
        x: newX,
        y: newY,
        duration: duration,
        onComplete: onCompleteHandler
        });
    }
    scene.tweens.timeline({
        tweens: tweens
    });
    }

</script>