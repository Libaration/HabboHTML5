<!doctype html> 
<html lang="en"> 
<head> 
    <meta charset="UTF-8" />
    <title>new map design test</title>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.52.0/dist/phaser.js"></script>
   <style type="text/css">
        body {
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background: #111
        }
    </style>
</head>
<body>

<script type="text/javascript">

   var config = {
        type: Phaser.AUTO,
        width: 800,
        height: 600,
        physics: {
            default: 'arcade',
            arcade: {
                gravity: {y : 0},
                debug: false
            }
        },
        scene: {
            preload: preload,
            create: create,
            update: update
        },
         pixelArt: true,
        //  zoom: 1.5
    };

    var game = new Phaser.Game(config);

    let tile;
    let grid;
    let mapContainer;
    let tilehover;
    let mouse;
    let map;
    var scene;
    const offsetX = 32*13
    const offsetY = 16*13
    let tween = null;
    function preload ()
    {
        //loads the sprites and assets to be used
        this.load.image('tile', 'assets/tile.png')
        this.load.image('tilehover', 'assets/tile_outline.png')
        this.load.tilemapTiledJSON("map", "assets/7x7.json")
        this.load.spritesheet('habbo', 'assets/habbospritesheet.png', { frameWidth: 128, frameHeight: 220 });
    }

    function create ()
    {   
        
        scene=this; // this is wrong. shouldn't be global. fix later
        // Set mouse variable and send to handleclick function on mouse up event
        mouse = this.input.mousePointer;
        this.input.on('pointerup',handleClick);

        //Create tilemap
        map = this.make.tilemap({key: 'map', tileWidth: 64, tileHeight: 32})
        const tileset = map.addTilesetImage('roomtile', 'tile',64,32,0,0)
        const worldLayer = map.createStaticLayer("ground", tileset, game.config.width/2 ,game.config.height/2);
        worldLayer.setOrigin(0,0)

        //add outline square for hovering over tiles
        tilehover = this.add.sprite(32 * 12, 16 * 12, 'tilehover')
        tilehover.depth = 2

        //creates habbo sprite and sets scale to match tilemap
        player = this.physics.add.sprite(32*12, 16*12, 'habbo')
        player.setScale(0.5)

        //Set Animations for habbo walking
        this.anims.create({
            key: 'left',
            frames: this.anims.generateFrameNumbers('habbo', {start: 1, end: 3}),
            frameRate: 10,
            repeat: -1
        });

        this.anims.create({
            key: 'right',
            frames: this.anims.generateFrameNumbers('habbo', { start: 4, end: 6 }),
            frameRate: 10,
            repeat: -1
        })
        this.anims.create({
            key: 'turn',
            frames: [{key: 'habbo', frame: 0}],
            frameRate: 20
        })
    }

    function update ()
    {
         
    }

    handleClick = (pointer) => {
        //prevents variable distance between tiles (currently only works for x axis)
        let distance = player.x - pointer.x;
        let speed = 120;
        let duration = (Math.sqrt(distance*distance) / speed) * 1000;

        //Finds which Tile (x,y) user clicked and returns world position for it
        let {x, y} = cartToIso()
        let newX = map.tileToWorldXY(x,y).x + 32 //why do i have to add here?
        let newY = map.tileToWorldXY(x,y).y - 32 // why am I subtracting? the math is wrong somewhere else

        //If user clicks begins walk animation depending on click direction again only on X axis as of now
        if (tween){
            console.log('Already walking')
            console.log('Stopping walking')
            tween.stop()
        }
        tween = scene.tweens.add({
        onStart: () => {
            console.log(`Starting walking to X:${newX}-Y:${newY}`)
            if(newX < player.x){
                //player.flipX = true; could use for other sprite directions i dont have
                player.anims.play('left', true)
            }
            else if(newX > player.x){
                player.anims.play('right', true)
            }
        },
        targets: player,
        x: newX,
        y: newY,
        duration: duration,
        onComplete: onCompleteHandler
        });
        
       
    }
    onCompleteHandler = () =>{
        //stops walking animation this should stop on last player direction in the future
        console.log(`Finished walking, arrived at X:${player.x}-Y:${player.y}`)
        player.anims.play({key: 'turn'})
        tween = null;
    }
    cartToIso = () => {
        //maths for finding the isometric square/tile cords for where the user clicks
        let x =  Math.floor((mouse.y / 32 + mouse.x / 64) - 16)
        let y = Math.floor( 0.5 * (-mouse.x / 32 + mouse.y / 16) -3)
        return {x: x, y: y}
    }

</script>

</body>
</html>